---
sidebar_position: 1
title: "Tree in C++"
description: "In this tutorial, we will learn about Tree in C++ programming with the help of examples."
sidebar_label: "Tree"
slug: tree-in-cpp
---

## Trees in C++: A Hierarchical Data Structure

Trees are a fundamental data structure in computer science, representing hierarchical relationships between data. They consist of *nodes* connected by *edges, forming a tree-like structure with a single **root node* at the top.

![Constants in CPP](../../static/img/day-04/constants-in-cpp.png)

*Key Features of Trees:*

* *Hierarchical structure:* Data is organized in levels, with a parent-child relationship between nodes.
* *Directed edges:* Edges point from parent nodes to child nodes.
* *One root node:* The tree has a single starting point, the root node.
* *No cycles:* There are no loops or paths that lead back to the same node.

*Types of Trees:*

* *Binary Trees:* Each node has at most two children.
* *N-ary Trees:* Each node can have multiple children.
* *Trie:* Specialized for string search and prefix matching.
* *B-trees:* Optimized for disk-based storage and retrieval.

*Common Operations:*

* *Traversal:* Visiting each node in the tree in a specific order (e.g., pre-order, in-order, post-order).
* *Insertion:* Adding new nodes to the tree.
* *Deletion:* Removing existing nodes from the tree.
* *Search:* Finding a specific node based on its value.

*Code Example (C++):*

cpp
#include <iostream>

// Node structure for the tree
struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int value) : data(value), left(nullptr), right(nullptr) {}
};

// Function to insert a new node into the tree
Node* insert(Node* root, int value) {
    if (root == nullptr) {
        return new Node(value);
    }

    if (value < root->data) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }

    return root;
}

// Function for in-order traversal of the tree
void inorderTraversal(Node* root) {
    if (root != nullptr) {
        inorderTraversal(root->left);
        std::cout << root->data << " ";
        inorderTraversal(root->right);
    }
}

int main() {
    // Create a sample tree
    Node* root = nullptr;
    root = insert(root, 8);
    root = insert(root, 3);
    root = insert(root, 10);
    root = insert(root, 1);
    root = insert(root, 6);
    root = insert(root, 14);

    // Print the tree using in-order traversal
    std::cout << "In-order Traversal: ";
    inorderTraversal(root);
    std::cout << std::endl;

    return 0;
}


*Explanation:*

1. *Node structure:* The Node struct represents a node in the tree, holding its data, left child pointer, and right child pointer.
2. **insert() function:** This function recursively inserts a new node into the tree based on its value.
3. **inorderTraversal() function:** This function performs an in-order traversal of the tree, visiting the left subtree, then the current node, and then the right subtree.
4. **main() function:**
   * Creates an empty tree (root = nullptr).
   * Inserts nodes with values 8, 3, 10, 1, 6, and 14 into the tree.
   * Prints the tree using in-order traversal.

*Output:*


In-order Traversal: 1 3 6 8 10 14


This output shows the nodes of the tree visited in the in-order traversal sequence, which is sorted by the node values.

*Key Points:*

* This example demonstrates a basic binary search tree (BST). 
* The insert() function ensures that the tree remains sorted in-order.
* Other traversal methods (pre-order, post-order) can be implemented similarly.
* This is a simple example. Trees can be extended with more complex operations, such as deletion, search, and balancing algorithms.

Trees are a versatile data structure used in various applications, including file systems, decision trees, and syntax trees.